# Phase 1 Gameplay Physics Analysis: Relay Server Requirements

## Executive Summary

A Phase 1 relay server needs **ZERO physics simulation** but **DOES need lightweight ship
state tracking** to support the Python scoring scripts. The scoring system relies on
engine-generated events (`ET_WEAPON_HIT`, `ET_OBJECT_EXPLODING`) that carry embedded data
fields. In the original architecture, these events are generated by the local game engine
(C++ physics/combat simulation running on each peer), not from the network. In our relay
model, these events must be reconstructed from network messages that clients send.

---

## 1. Ship State for Scoring

### What the scoring scripts access

From Mission1.py `DamageHandler`:
```python
iHitterID = pEvent.GetFiringPlayerID()     # who fired the weapon
fDamage = pEvent.GetDamage()               # damage amount (float)
bHullHit = pEvent.IsHullHit()              # 0 = shield, 1 = hull
pShip = App.ShipClass_Cast(pEvent.GetDestination())  # ship that was hit
pShip.IsPlayerShip()                       # is it a player ship?
pShip.GetObjID()                           # internal object ID
pShip.GetNetPlayerID()                     # network player ID of ship owner
pShip.GetNetType()                         # species/ship class index
pShip.GetName()                            # ship name string
```

From Mission1.py `ObjectKilledHandler`:
```python
iFiringPlayerID = pEvent.GetFiringPlayerID()    # who dealt killing blow
pKilledObject = pEvent.GetDestination()         # the destroyed object
pKilledObject.IsTypeOf(App.CT_SHIP)             # type checking
pShip = App.ShipClass_Cast(pKilledObject)
pShip.IsPlayerShip()                            # player vs AI
pShip.GetNetPlayerID()                          # owner's player ID
pShip.GetObjID()                                # object ID
```

From MissionShared.py `WarpHandler`:
```python
pPlayer.IsDying()                               # is the ship dying?
pPlayer.IsDead()                                # is the ship dead?
```

### Where do these values come from?

**In the original architecture:** These values come from the LOCAL C++ engine simulation.
Every peer runs the full game engine. When a torpedo hits a ship on the host's machine,
the host's C++ collision system generates an `ET_WEAPON_HIT` event locally, populated with
damage values computed by the host's physics/damage engine. The host's Python scoring
scripts then process that event.

**Key insight:** `GetDamage()` returns a value computed by the C++ damage system from the
weapon properties and impact. It is NOT embedded in a network message from another client.
Similarly, `IsHullHit()` is determined by the host's local shield state simulation -- if
the shield facing has HP remaining, it's a shield hit; if not, it bleeds through to hull.

**Implication for relay server:** Since we are NOT running physics simulation, we cannot
locally generate these events. We have two options:

**Option A: Client-Reported Events (Recommended for Phase 1)**
- Clients run their own full simulation (just like the original)
- The client whose ship FIRED the weapon reports the hit event to the server
  (damage amount, hull/shield, target ID, firing player ID)
- The server trusts these reports and reconstructs the event objects for Python
- This matches the original trust model (peers trusted each other)

**Option B: Server-Authoritative (Phase 2)**
- Server runs physics, computes damage itself
- Events are generated server-side from collision detection
- Clients are only authoritative for their inputs (throttle, firing commands)

### Minimum server-side ship state for scoring

For Option A, the server needs to maintain per-ship:

| Field              | Type    | Source                    | Used By               |
|--------------------|---------|---------------------------|-----------------------|
| NetPlayerID        | int     | Player connection         | Kill attribution      |
| ObjID              | int     | Object creation           | Damage dict keying    |
| NetType (species)  | int     | Ship selection message    | Class modifier lookup |
| Name               | string  | Ship creation             | Kill subtitles        |
| IsPlayerShip       | bool    | Ship creation             | Score filtering       |
| IsDying            | bool    | Explosion event           | Warp prevention       |
| IsDead             | bool    | Destruction event         | State tracking        |

**These are all metadata fields, not physics state.**

---

## 2. Ship Destruction Events

### How destruction works in the original

1. A ship's hull HP reaches zero (computed by C++ damage model)
2. The C++ engine generates `ET_OBJECT_EXPLODING` locally on every peer
3. On the host, `ObjectKilledHandler` runs in Python, processes the kill
4. `ET_OBJECT_EXPLODING` carries `GetFiringPlayerID()` -- the player who dealt the killing blow
5. The host sends a `SCORE_CHANGE_MESSAGE` to all other clients with updated scores

### Does the client send the explosion event?

**No, not directly.** In the original model, every peer independently detects the ship
destruction because every peer runs the full simulation. The explosion happens simultaneously
on all peers (approximately -- network state sync keeps them close enough).

However, the `ObjectExplodingHandler` in MultiplayerGame IS registered as
a handler and likely relays the explosion event to other peers for synchronization. The
pattern would be: the peer where the ship's hull reaches zero first generates the event,
and the host relays it.

### For the relay server

Since we are not simulating hull HP, the server cannot independently detect ship death.
The client that detects its own death (or another client's ship destruction) must report it.

**Recommended approach:**
- Treat the `ET_OBJECT_EXPLODING` relay from clients as authoritative
- The client whose ship was destroyed is the most trustworthy reporter
- Reconstruct `ObjectExplodingEvent` with `GetFiringPlayerID()` from the relay message
- Fire the Python `ObjectKilledHandler` on the server with this reconstructed event

---

## 3. Collision Damage

### How collisions work in the original

`SERVER_COLLISIONS = 1` in DedicatedServer.py controls:
```python
App.ProximityManager_SetPlayerCollisionsEnabled(SERVER_COLLISIONS)
App.ProximityManager_SetMultiplayerPlayerCollisionsEnabled(SERVER_COLLISIONS)
```

This enables/disables the C++ ProximityManager's collision detection between player ships.
Collision damage is computed locally by each peer's C++ engine -- there is no network
message for "collision occurred." Each peer detects collisions independently based on its
local simulation of ship positions.

### For the relay server

**Phase 1:** Collision damage is NOT reportable by clients in the original protocol.
There is no network message for "ship A collided with ship B for X damage."

The collisions are a side effect of the physics engine running on each peer. In a relay
model without server-side physics:
- Collisions still happen on each client locally
- The DAMAGE from collisions gets picked up by `ET_WEAPON_HIT` or similar damage events
  on each client
- But since each client runs independently, collision results may differ slightly

**Note:** Mission5.py explicitly calls `g_pStarbase.DisableCollisionDamage(1)` for the
starbase, confirming collisions are handled by the C++ engine, not Python scripts.

**Recommendation:** For Phase 1, collision damage is purely client-side. The server does
not need to know about it. Clients will see collision damage locally. If a collision kills
a ship, the death event will be relayed to the server like any other death.

---

## 4. Ship Position Tracking

### Does the server need to know WHERE ships are?

**Searched all multiplayer mission scripts for position queries.** Findings:

- `SetTranslate()` is used in ship spawn logic (Mission1Menus.py line 813) -- placing a
  newly created ship at a random empty location. This runs on the client that's spawning.
- `SetTranslate()` is used in Mission5.py for starbase placement (lines 1473, 1496) --
  this is host-side logic for creating the AI starbase.
- `GetWorldLocation()`, `GetPosition()`, `GetWorldTransform()` -- **NOT used in any
  multiplayer scoring script.**

**The scoring system NEVER queries ship position.** It only cares about:
- WHO fired (player ID)
- WHO was hit (ship object ID, player ID)
- HOW MUCH damage (float value)
- WHAT KIND (shield vs hull)
- WAS IT DESTROYED (exploding event)

**Conclusion:** The relay server does NOT need position tracking for scoring.

**Exception:** Mission5.py's `CreateStarbase()` creates and positions an AI starbase on
the host. If the server needs to host Mission5 (Starbase Siege), it would need basic
`Set.IsLocationEmptyTG()` and `SetTranslate()` support. But this is spawn placement,
not continuous position tracking.

---

## 5. Damage Model on Server

### Where does `pEvent.GetDamage()` come from?

**It is computed locally by the C++ engine**, not embedded in a network message from the
shooting client. The computation chain:

1. Weapon fires (C++ weapon system)
2. Projectile hits target (C++ collision detection)
3. Damage is computed from weapon properties (DamageBase, DamageRadiusFactor, etc.)
4. Shield absorption is computed (C++ shield system)
5. Remaining damage bleeds to hull if shield is depleted
6. `WeaponHitEvent` is created with final damage value, hull/shield flag
7. Event is dispatched to Python handlers

### For the relay server

Since we do not run this C++ pipeline, the damage value must come from the client that
computed it. The client-side engine computes damage using its local weapon/shield state,
and we need to relay that value.

**DamageHandler scoring formula (from Python):**
```python
fDamage = pEvent.GetDamage()
fDamage = fDamage * Multiplayer.Modifier.GetModifier(iHitterClass, iHitClass)
# Modifier table: Class 0 = 1.0x, Class 1 = 1.0x, Class 2 attacking Class 1 = 3.0x
```

Score calculation on kill:
```python
fDamageDone = fShieldDamageDone + fHullDamageDone
fDamageDone = fDamageDone / 10.0  # Reduce by factor of 10
fScore = fPreviousScore + fDamageDone
g_kScoresDictionary[iPlayerID] = int(fScore)
```

All of this is pure Python arithmetic on values that come from the event. The server
just needs the event values; it does not need to simulate damage itself.

---

## 6. What Phase 2 Adds

Phase 2 moves from client-trusted relay to server-authoritative simulation. This requires:

### Must Implement
1. **Ship flight model** -- Euler integration, throttle/turn input processing
   - Read ThrottleInput (from client), write Transform/PhysicsBody
   - Fixed 30Hz timestep
2. **Weapon projectile tracking** -- torpedo spawning, travel, lifetime
   - Ray-cast for phasers (instant hit)
   - Projectile entities for torpedoes (travel over time)
3. **Collision detection** -- sphere-sphere for ships, sphere-sphere for torpedoes
   - Ship collision radius from Hull.Radius in Hardpoints
   - Brute force is fine for 16-32 entities
4. **Shield state management** -- 6 facings, per-facing HP, recharge
   - Determine which facing was hit based on hit direction vs ship orientation
   - Reduce facing HP, compute bleedthrough
5. **Hull/subsystem damage** -- hull HP, subsystem degradation
   - Subsystem damage affecting performance (engine damage = reduced speed)
   - Critical subsystem destruction (WarpCore = ship destruction)
6. **Damage calculation** -- weapon properties to damage values
   - Phaser: continuous DPS based on charge level
   - Torpedo: burst damage on impact
   - Pulse: rapid-fire projectile damage
7. **AI ship behavior** -- for mission types that have AI ships (starbase in Mission5)

### Can Defer to Phase 3+
- Power management (warp core output, conduit capacity, battery reserves)
- Repair queue with priority and complexity
- Detailed subsystem position-based hit detection (which specific subsystem was hit)
- Visual effects (explosion animations, particle physics)

---

## 7. Phase 1 Stub Requirements

### App.* functions the scoring scripts call on the server

These must exist as working stubs/implementations:

#### Event System (CRITICAL -- needed for scoring)
```
App.g_kEventManager.AddBroadcastPythonFuncHandler(eventType, object, handlerName)
App.TGEvent.GetDestination()
App.TGEvent.GetSource()
```

#### WeaponHitEvent (CRITICAL -- needed for DamageHandler)
```
WeaponHitEvent.GetDamage() -> float
WeaponHitEvent.IsHullHit() -> int (0 or 1)
WeaponHitEvent.GetFiringPlayerID() -> int
WeaponHitEvent.GetDestination() -> TGObject
```

#### ObjectExplodingEvent (CRITICAL -- needed for ObjectKilledHandler)
```
ObjectExplodingEvent.GetFiringPlayerID() -> int
ObjectExplodingEvent.GetDestination() -> TGObject
```

#### Ship Object (CRITICAL -- accessed in scoring handlers)
```
ShipClass_Cast(obj) -> ShipClass or None
ShipClass.IsPlayerShip() -> int (0 or 1)
ShipClass.GetObjID() -> int
ShipClass.GetNetPlayerID() -> int
ShipClass.GetNetType() -> int
ShipClass.GetName() -> string
ShipClass.IsDying() -> int (0 or 1)
ShipClass.IsDead() -> int (0 or 1)
```

#### Type System (used in ObjectKilledHandler)
```
TGObject.IsTypeOf(classType) -> int
App.CT_SHIP  # constant
```

#### Game/Network (used everywhere in scoring)
```
App.g_kUtopiaModule.IsHost() -> int
App.g_kUtopiaModule.IsClient() -> int
App.g_kUtopiaModule.GetNetwork() -> TGNetwork
App.g_kUtopiaModule.GetGameTime() -> float
App.g_kUtopiaModule.GetRealTime() -> float
TGNetwork.GetHostID() -> int
TGNetwork.GetLocalID() -> int
TGNetwork.GetPlayerList() -> PlayerList
TGNetwork.SendTGMessage(targetID, message)
TGNetwork.SendTGMessageToGroup(groupName, message)
TGNetwork.GetConnectStatus() -> int
App.TGNETWORK_CONNECTED  # constant
App.TGNETWORK_CONNECT_IN_PROGRESS  # constant
```

#### MultiplayerGame (used for player-ship mapping)
```
App.MultiplayerGame_Cast(game) -> MultiplayerGame
MultiplayerGame.GetShipFromPlayerID(playerID) -> ShipClass or None
MultiplayerGame.SetPlayer(ship)
MultiplayerGame.DeletePlayerShipsAndTorps()
MultiplayerGame.DeleteObjectFromGame(obj)
MultiplayerGame.SetReadyForNewPlayers(flag)
```

#### Message System (used for score broadcasts)
```
App.TGMessage_Create() -> TGMessage
TGMessage.SetGuaranteed(flag)
TGMessage.SetDataFromStream(stream)
TGMessage.GetBufferStream() -> TGBufferStream
TGMessage.Copy() -> TGMessage
App.TGBufferStream()
TGBufferStream.OpenBuffer(size)
TGBufferStream.CloseBuffer()
TGBufferStream.Close()
TGBufferStream.ReadChar() -> char
TGBufferStream.ReadLong() -> int
TGBufferStream.ReadInt() -> int
TGBufferStream.WriteChar(char)
TGBufferStream.WriteLong(int)
TGBufferStream.WriteInt(int)
```

#### Player System
```
PlayerList.GetNumPlayers() -> int
PlayerList.GetPlayerAtIndex(index) -> Player
PlayerList.GetPlayer(playerID) -> Player
Player.GetNetID() -> int
Player.GetName() -> TGString
TGString.GetCString() -> string
```

#### Mission System
```
MissionLib.GetMission() -> Mission
Mission.GetScript() -> string
Mission.GetEnemyGroup() -> ObjectGroup
Mission.GetFriendlyGroup() -> ObjectGroup
ObjectGroup.AddName(name)
ObjectGroup.RemoveAllNames()
ObjectGroup.RemoveName(name)
ObjectGroup.IsNameInGroup(name) -> bool
```

#### Timer System (for time limits)
```
App.g_kTimerManager.DeleteTimer(timerID)
MissionLib.CreateTimer(eventType, handler, startTime, interval, duration, arg1, arg2)
```

#### Utility
```
App.IsNull(obj) -> bool
App.NULL_ID  # constant
App.Game_GetCurrentGame() -> Game
App.BaseObjectClass_GetObject(set, name) -> object or None
App.MAX_MESSAGE_TYPES  # constant
App.g_kVarManager.MakeEpisodeEventType(num) -> int
```

### Functions NOT needed for Phase 1

These are used only on clients (UI, rendering, audio), never on the server side:

```
# UI functions -- client only
App.TopWindow_GetTopWindow()
App.MultiplayerWindow_Cast()
App.SubtitleAction_*
App.TGSequence_*
App.TGSoundAction_*

# Position/physics -- not used in scoring
ShipClass.GetWorldLocation()
ShipClass.GetTranslate()
ShipClass.SetTranslate()  # except for spawn placement

# Rendering
ShipClass.SetupModel()
ShipClass.UpdateNodeOnly()

# Ship properties -- not queried by scoring
ShipClass.GetRadius()
ShipClass.GetPropertySet()
ShipClass.SetupProperties()
```

---

## 8. Architecture Recommendation for Phase 1

```
                    Client A                    Server                   Client B
                    --------                    ------                   --------
                    Full Engine                 Relay +                  Full Engine
                    (physics,                   Python                   (physics,
                     rendering,                 Scoring                   rendering,
                     damage calc)                                         damage calc)

   A fires at B --> [engine computes damage]
                    --> sends WeaponHit msg ---> receives msg
                                                reconstructs event
                                                calls DamageHandler()
                                                updates score dicts
                                                                    --> relays to B
                                                                        B also computed
                                                                        damage locally

   B's hull = 0 --> [engine detects death]
                    --> sends Exploding msg ---> receives msg
                                                reconstructs event
                                                calls ObjectKilledHandler()
                                                computes final scores
                                                sends SCORE_CHANGE to all
                                                                    --> relays to A
```

The server is a "smart relay" -- it relays game traffic AND runs Python scoring scripts
using reconstructed events. It maintains a lightweight ship registry (player-to-ship
mapping, ship metadata) but NO physics state.

---

## 9. Event Data Requirements in Network Messages

For the server to run scoring scripts, the following data must be present in relayed messages:

### WeaponHit Relay (client -> server)
| Field           | Type  | Notes                              |
|-----------------|-------|------------------------------------|
| FiringPlayerID  | int32 | Who fired                          |
| TargetObjID     | int32 | Ship that was hit                  |
| Damage          | float | Computed damage value              |
| IsHullHit       | uint8 | 0 = shield, 1 = hull               |

### ObjectExploding Relay (client -> server)
| Field           | Type  | Notes                              |
|-----------------|-------|------------------------------------|
| FiringPlayerID  | int32 | Who dealt killing blow              |
| DestroyedObjID  | int32 | Ship that was destroyed             |

### These may already be embedded in the original protocol
The C++ MultiplayerGame handlers (StartFiringHandler, ObjectExplodingHandler, etc.) relay
events between peers. The relay format likely includes these fields since every peer needs
them to maintain synchronized game state. Reverse engineering of the network payload at
these handler addresses will reveal the exact wire format.
