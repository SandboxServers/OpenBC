# OpenBC: Design Decisions

Key architectural decisions made during the project's design phase. Extracted from the original requirements document (see [../archive/phase1-requirements.md](../archive/phase1-requirements.md) Section 5).

---

### DD-01: Raw UDP, Not ENet
ENet wire format is incompatible with vanilla BC clients. The custom TGNetwork protocol must be reimplemented from scratch.

### DD-02: Standalone C, Not Python/SWIG
The previous design embedded Python 3.x and reimplemented ~595 SWIG API functions to run original BC scripts. This was replaced with a standalone C server because:
- Eliminates ~40,000 LOC of compatibility layer code
- Removes Python 3.x runtime dependency (~30 MB)
- Removes Python 1.5.2 compatibility shim complexity
- Enables < 20 MB memory footprint vs. ~100 MB with Python
- Startup in < 1 second vs. ~5 seconds for Python init + script loading
- All game logic expressed as data (JSON) is simpler, more maintainable, and more moddable than reimplementing the script execution environment
- Server operators configure via CLI flags, not by editing Python scripts

### DD-03: Hash Manifests, Not Live Hashing
The server does not need game files. It needs precomputed hash values. Benefits:
- Zero copyrighted material on the server
- Faster checksum validation (compare precomputed values, not hash files on disk)
- Supports any mod combination via multiple manifest files
- Manifest generation is a one-time offline step, not a runtime dependency

### DD-04: Data-Driven Design
Ship stats, weapon configs, maps, and game rules live in JSON data files:
- Server operators can tune gameplay without programming
- Mods are data packs, not code patches
- The data registry supports layered overrides (base + mod)
- Adding a new ship class requires zero code changes

### DD-05: Mesh-Accurate Collision
OpenBC implements mesh-accurate collisions matching the original NetImmerse proximity manager fidelity:
- **Broad phase**: bounding sphere (cheap filter)
- **Narrow phase**: convex hulls extracted from NIF geometry (accurate)
- Collision data generated by a build-time tool, stored in the data registry
- This matches original BC behavior where the NetImmerse engine performs mesh-level intersection tests

### DD-06: Phased Development (A through E)
Each phase produces a working, testable deliverable:
- **Phase A**: Hash manifest tool (standalone, no server)
- **Phase B**: Protocol codec library (encode/decode any BC packet)
- **Phase C**: Lobby server (connect, checksum, chat -- no gameplay)
- **Phase D**: Relay server (gameplay via message forwarding)
- **Phase E**: Simulation server (server-authoritative physics and damage)

### DD-07: Internet Play via GameSpy Protocol
The original BC uses GameSpy for server discovery. Community-maintained replacements (333networks, OpenSpy) provide drop-in compatible master server infrastructure. OpenBC implements the standard GameSpy heartbeat/query protocol to support internet play out of the box.
