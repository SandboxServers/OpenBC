# OpenBC Phase 1: Playable Dedicated Server - Requirements Document

## Document Status
- **Generated**: 2026-02-07, **Revised**: 2026-02-15 (opcode table corrections, RE risk downgrades)
- **Source**: Synthesized from 9 specialized agent analyses (gameplay expansion round)
- **Agents consulted**: openbc-architect, game-reverse-engineer, swig-api-compat, stbc-original-dev, network-protocol, python-migration, flecs-ecs-architect, physics-sim, mod-compat-tester

---

## 1. Executive Summary

Phase 1 delivers a **playable headless dedicated server** that speaks the legacy Bridge Commander multiplayer protocol. Vanilla BC clients (purchased from GOG) can discover the server on LAN, connect, pass checksum verification, select ships, and **play complete multiplayer matches** (FFA deathmatch, team deathmatch, team objectives).

The server operates as a **message relay**: it forwards game state (ship positions, weapon fire, damage) between connected clients without simulating physics, AI, or combat. Each client runs the full game simulation locally. Game lifecycle management (lobby, ship selection, game start/end/restart) and chat relay are handled by the server.

Server-side scoring (kill/death tracking via Python mission scripts) is **deferred to Phase 2**, where the server will gain the ability to synthesize gameplay events from the relay stream.

### Success Criteria

A vanilla, unmodified Star Trek: Bridge Commander client can:
1. Discover the OpenBC server in the LAN multiplayer browser
2. Connect to the server and receive a player slot assignment
3. Complete the 4-round checksum exchange
4. Receive game settings and reach the ship selection screen
5. Select a ship and have it broadcast to all other connected clients
6. **Play a complete multiplayer match** (movement, weapons, combat all functional via relay)
7. **Chat with other players** during lobby and gameplay
8. Experience **game end** (time limit, frag limit) and **restart**
9. Up to 16 clients connected simultaneously
10. Remain connected without spurious timeouts
11. Disconnect cleanly with slot recovery
12. **Reconnect mid-game** (late join with game state sync)

---

## 2. Scope

### 2.1 In Scope

| Subsystem | Description |
|-----------|-------------|
| **Network protocol** | TGWinsockNetwork reimplementation via raw UDP sockets |
| **Message relay** | Clone-and-forward of all game messages between connected peers |
| **GameSpy LAN discovery** | Query/response for server browser visibility |
| **Event system** | TGEventManager / TGEvent / handler dispatch |
| **Checksum exchange** | 4-round file hash verification (opcodes 0x20-0x28) |
| **Player slot management** | 16-slot array with connect/disconnect lifecycle |
| **Ship object model** | Lightweight ship entities for script reference (identity, ownership, state) |
| **Game lifecycle** | State machine: Lobby -> Ship Select -> Playing -> Game Over -> Restart |
| **Chat relay** | Text message forwarding between clients (regular + team chat) |
| **Peer groups** | Named peer groups ("NoMe" = all except self) for targeted sends |
| **Python 3.x embedding** | Interpreter with 1.5.2 compatibility shim |
| **App/Appc SWIG API** | ~595 server-relevant functions + ~345 constants |
| **Config system** | TGConfigMapping for .cfg file reading |
| **Timer system** | TGTimerManager for time-based events |
| **flecs ECS world** | Game state backbone with gameplay components |
| **Build system** | CMake + CI/CD + Docker container |
| **Multiplayer missions 1-3** | FFA deathmatch, Team DM, Team objectives (script loading + lifecycle) |
| **Ship property loading** | Hardpoint file execution for ship creation |
| **UI stubs** | ~80+ no-op functions for headless mode compatibility |

### 2.2 Out of Scope

| Subsystem | Phase | Rationale |
|-----------|-------|-----------|
| Rendering (bgfx, NIF loading) | Phase 3 | Server is headless |
| Audio (miniaudio) | Phase 4 | Server is headless |
| UI (RmlUi) | Phase 4 | Server is headless |
| Input (SDL3 input events) | Phase 4 | Server is headless |
| Scene graph (NiNode hierarchy) | Phase 3 | No rendering |
| **Server-side scoring** | **Phase 2** | Requires event synthesis from relay stream |
| **Server-authoritative physics** | Phase 2 | Phase 1 trusts clients |
| **AI systems** | Phase 2 | Mission5 (coop) deferred |
| **Mission5 (Coop vs AI)** | Phase 2 | Requires AI + ship simulation on server |
| Single-player / bridge crew | Phase 4 | Client-only |
| Save/load | Phase 4 | Client-only |

### 2.3 Scoring Deferral (Design Decision)

In the original BC, the host runs the full C++ game engine locally. Events like `ET_WEAPON_HIT` and `ET_OBJECT_EXPLODING` are generated by the host's local damage/collision pipeline and processed by Python scoring scripts. A relay-only server has no C++ damage engine, so these events never fire.

**Phase 1**: Gameplay works because all clients simulate independently and agree on outcomes. Scores display on each client based on their local simulation. There is no authoritative server-side scoreboard.

**Phase 2**: The server will parse specific opcodes from the relay stream, synthesize Python events, and feed them to the mission scoring scripts for authoritative score tracking.

**Note**: The STBC-Dedicated-Server project has demonstrated working headless scoring using `ObjectKilledHandler` to send `SCORE_CHANGE_MESSAGE` on kills, implemented via the Appc functional API. This approach can inform Phase 2 design.

---

## 3. Functional Requirements

### REQ-NET: Network Protocol

#### REQ-NET-01: Raw UDP Transport
The server MUST use raw UDP sockets (NOT ENet) to communicate with vanilla BC clients. The wire format is incompatible with any existing networking library.

#### REQ-NET-02: Shared UDP Socket
Single UDP socket (default port 22101/0x5655) shared between GameSpy and game protocol via peek-based first-byte demultiplexing (`\` = GameSpy, binary = game).

#### REQ-NET-03: Packet Wire Format
All game packets are encrypted with the AlbyRules stream cipher (XOR with "AlbyRules!" key). After decryption:
```
[direction: u8] [messageCount: u8] [message[0]...] ... [message[N-1]...]
```
Direction: 0x01=from server, 0x02=from client, 0xFF=init handshake. Max 254 messages per packet. Default max packet size 512 bytes. See [phase1-verified-protocol.md](phase1-verified-protocol.md) for complete wire format.

#### REQ-NET-04: Message Types
| Type | Name | Purpose |
|------|------|---------|
| 0 | Connection | New peer introduction |
| 1 | ACK | Reliable message acknowledgment |
| 2 | Internal | Padding/discard |
| 3 | Data | Game payload (carries opcodes 0x00-0x2B+) |
| 4 | Disconnect | Peer leaving |
| 5 | Keepalive | Connection maintenance |

#### REQ-NET-05: Three-Tier Send Queues
Per peer: Priority Reliable (ACKs, retried 8x), Reliable (guaranteed, 360s timeout), Unreliable (fire-and-forget).

#### REQ-NET-06: Reliable Delivery
Sequence numbering (u16 wrapping), ACK generation, retry with timeout, disconnect after 8 priority retries, sequence window validation (0x4000 range).

#### REQ-NET-07: Connection Handshake
Accept connection messages (type 0) from unknown peers (peerID=-1), create peer, assign ID, fire ET_NETWORK_NEW_PLAYER.

#### REQ-NET-08: Connection State Machine
HOST state (value 2) only in Phase 1. States: 4=DISCONNECTED, 2=HOST, 3=CLIENT (not implemented).

#### REQ-NET-09: Peer Management
Sorted array, binary-searched by peer ID. Max 16 simultaneous peers. Creation on connect, removal on disconnect/timeout.

#### REQ-NET-10: Timeout Handling
Reliable message timeout: 360s. Disconnect timeout: 45s. Priority max retries: 8.

### REQ-RLY: Message Relay

#### REQ-RLY-01: Game Message Relay
The server MUST clone and forward all incoming game data messages (type 3) to all other connected peers. The relay operates on raw message bytes -- no deserialization or re-serialization is needed.

**Implementation**: For each received data message, read byte[1] (sender player slot index), iterate all 16 player slots, and for each active slot that is NOT the sender and NOT self, clone the raw message and send via TGNetwork::Send.

#### REQ-RLY-02: Game Opcodes (verified from jump table at 0x0069F534)
The server MUST relay all game message types (opcodes 0x00-0x2A, with gaps). Key opcodes:
| Opcode | Name | Server Action |
|--------|------|---------------|
| 0x00 | Settings | Server generates (post-checksum) |
| 0x01 | GameInit | Server generates (post-checksum) |
| 0x02 | ObjectCreate | Relay + optionally create ship entity |
| 0x03 | ObjectCreateTeam | Relay + create ship entity |
| 0x04 | BootPlayer | Server generates (reject/kick) |
| 0x07-0x0C | Event forwards (firing, subsystem, etc.) | Pure relay |
| 0x14 | DestroyObject | Relay + update ship death state |
| 0x19 | TorpedoFire | Pure relay |
| 0x1A | BeamFire | Pure relay |
| 0x1C | StateUpdate | Pure relay (unreliable, position/state) |
| 0x2A | NewPlayerInGame | Server generates (player join) |
| All others | Various | Pure relay |

See [phase1-verified-protocol.md](phase1-verified-protocol.md) for the complete verified opcode table with handler addresses and packet counts.

#### REQ-RLY-03: Python Script Message Relay
Python-level messages (opcode >= MAX_MESSAGE_TYPES = **0x2B**) MUST be relayed according to the script's send pattern:
| Message | Opcode | Relay Pattern |
|---------|--------|---------------|
| CHAT_MESSAGE | 0x2C | Client->Host, Host->Group("NoMe") |
| TEAM_CHAT_MESSAGE | 0x2D | Client->Host, Host->teammates only |
| MISSION_INIT_MESSAGE | 0x35 | Host->specific client (on join) |
| SCORE_CHANGE_MESSAGE | 0x36 | Deferred to Phase 2 |
| SCORE_MESSAGE | 0x37 | Deferred to Phase 2 |
| END_GAME_MESSAGE | 0x38 | Host->all (broadcast) |
| RESTART_GAME_MESSAGE | 0x39 | Host->all (broadcast) |

See [phase1-verified-protocol.md](phase1-verified-protocol.md) Section 6 for the complete Python message table.

#### REQ-RLY-04: Peer Groups
The server MUST support named peer groups with at minimum the "NoMe" group (all peers except the host/server). `SendTGMessageToGroup("NoMe", msg)` sends to all connected clients.

### REQ-GS: GameSpy LAN Discovery

#### REQ-GS-01: Query Response
Respond to `\basic\`, `\status\`, `\info\` with backslash-delimited key-value pairs (hostname, numplayers, maxplayers, mapname, gametype, hostport).

#### REQ-GS-02: LAN Broadcast
Server MUST be discoverable by vanilla BC clients scanning for LAN games.

### REQ-CHK: Checksum Exchange

#### REQ-CHK-01: Four-Round Verification
Sequential checksum requests for: scripts/App.pyc, scripts/Autoexec.pyc, scripts/ships/*.pyc (recursive), scripts/mainmenu/*.pyc.

#### REQ-CHK-02: Hash Algorithm
4-table byte-XOR substitution hash (FUN_007202e0) using four 256-byte lookup tables from stbc.exe addresses 0x0095c888-0x0095cb87.

#### REQ-CHK-03: Skip Checksums Option
Config flag (DAT_0097f94c) to bypass verification entirely.

#### REQ-CHK-04: Post-Checksum Settings
Opcode 0x00 (settings) + opcode 0x01 (status) sent as reliable messages after all checksums pass.

### REQ-EVT: Event System

#### REQ-EVT-01: Event Manager
Ring buffer queue, handler registry (hash map), C and Python handler support, broadcast and per-instance handlers, CallNextHandler chain walking.

#### REQ-EVT-02: Event Types
All ET_* constants with correct numeric values. Confirmed values:
| Event | Value |
|-------|-------|
| ET_NETWORK_MESSAGE_EVENT | 0x60001 |
| ET_NETWORK_CONNECT_EVENT | 0x60002 |
| ET_CHECKSUM_COMPLETE | 0x8000e8 |
| ET_SYSTEM_CHECKSUM_FAILED | 0x8000e7 |
| ET_KILL_GAME | 0x8000e9 |
| ET_START | 0x800053 |
| ET_OBJECT_CREATED_NOTIFY | (extract from Appc.pyd) |
| ET_OBJECT_EXPLODING | (extract from Appc.pyd) |
| ET_WEAPON_HIT | (extract from Appc.pyd) |
| ET_NEW_PLAYER_IN_GAME | (extract from Appc.pyd) |
| ET_NETWORK_DELETE_PLAYER | (extract from Appc.pyd) |

### REQ-PLR: Player Management

#### REQ-PLR-01: 16-Slot Array
Player slots at MultiplayerGame+0x74, stride 0x18: active flag, peer ID, player object ID.

#### REQ-PLR-02: Slot Assignment
First empty slot on connection. Rejection message if full.

#### REQ-PLR-03: Disconnect Handling
Clear slot, fire ET_NETWORK_DISCONNECT, free resources.

### REQ-SHIP: Ship Object Model

#### REQ-SHIP-01: Lightweight Ship Entities
The server MUST create ship entities when clients select ships. These are lightweight data containers (~80 bytes), NOT full simulation objects. Required queryable fields:
- `GetObjID()` -> unique 32-bit object ID (monotonic counter, never recycled per session)
- `GetNetType()` -> species index (SPECIES_GALAXY, etc.)
- `GetNetPlayerID()` -> owning player's network ID (0 = AI)
- `IsPlayerShip()` -> true if player-controlled
- `GetName()` -> ship name string
- `IsDying()` / `IsDead()` -> death state flags

#### REQ-SHIP-02: Ship-Player Lookup
`MultiplayerGame.GetShipFromPlayerID(playerID)` MUST resolve to the correct ship entity via direct array lookup.

#### REQ-SHIP-03: Ship Lifecycle
- **Create**: On ObjectCreateTeam opcode (**0x03**) from client
- **Death**: Tag transition Alive -> Dying -> Dead on DestroyObject opcode (**0x14**)
- **Respawn**: Delete old entity, create new entity with new ObjID
- **Game restart**: Delete all ship entities via `DeletePlayerShipsAndTorps()`

#### REQ-SHIP-04: No Torpedo Entities
Torpedo/projectile entities are NOT needed on the server. All scoring-relevant data (damage, firing player ID, hull hit flag) is embedded in network messages.

#### REQ-SHIP-05: Property System
The server MUST support the 16 `*Property_Create` functions and their `Set*` methods for hardpoint file execution. A generic property base class that accepts any Set*/Get* call as a no-op is acceptable -- scripts write properties during ship creation but the relay server does not use them for damage calculation.

### REQ-LIFE: Game Lifecycle

#### REQ-LIFE-01: State Machine
The server MUST implement a game lifecycle state machine:
| State | Description | Message Relay | Accept Players |
|-------|-------------|---------------|---------------|
| LOBBY | Waiting for players, checksum exchange | No | Yes |
| SHIP_SELECT | Players choosing ships | Chat only | Yes |
| PLAYING | Active match | Full relay | Yes (late join) |
| GAME_OVER | Scores displayed | Chat only | No |
| RESTARTING | Cleanup, back to ship select | No | No |

#### REQ-LIFE-02: Game Start
Triggered by Python scripts. Host sends MISSION_INIT_MESSAGE to all clients with game parameters (player limit, system type, time/frag limits).

#### REQ-LIFE-03: Game End
Host sends END_GAME_MESSAGE with reason code (time up, frag limit, etc.). Sets ReadyForNewPlayers(0).

#### REQ-LIFE-04: Game Restart
Host sends RESTART_GAME_MESSAGE broadcast. Clients reset, return to ship select.

#### REQ-LIFE-05: Late Join
When a player joins mid-game, `InitNetwork(iToID)` sends current mission config to the joining player.

### REQ-CHAT: Chat System

#### REQ-CHAT-01: Regular Chat
Client sends CHAT_MESSAGE (0x2C) to host. Host forwards to group "NoMe" (all other clients). Format: `[opcode:1][senderSlot:1][padding:3][stringLen:2][string:N]`, reliable.

#### REQ-CHAT-02: Team Chat
Client sends TEAM_CHAT_MESSAGE (0x2D) to host. Host forwards only to teammates. Same format as regular chat.

### REQ-PY: Python Scripting

#### REQ-PY-01: Python 3.x Embedding
Embed Python 3.8+ with App/Appc modules registered via PyImport_AppendInittab.

#### REQ-PY-02: Compatibility Shim
Handle Python 1.5.2 constructs:
- `dict.has_key(k)` (193 occurrences in gameplay scripts)
- `list.sort(cmp_func)` (11 occurrences -- breaking change in Python 3)
- `chr()`/`ord()` patterns (103 occurrences)
- `apply()`, `cmp()`, `execfile()`, `reload()`
- Module aliases: `cPickle`->`pickle`, `new`, `strop`, `imp`

#### REQ-PY-03: Source Transformation
Import hook for syntax: `print "text"`, `except E, e:`, `raise X, msg`, backtick repr, integer division.

#### REQ-PY-04: App.py Rewrite
Rewrite App.py as modern Python 3.x module (original has 1,004 `apply()` + 2,521 `new.instancemethod()` calls).

#### REQ-PY-05: Mission Script Execution
Multiplayer mission scripts (Mission1-3, MissionShared, MissionMenusShared, SpeciesToShip/Torp/System) MUST load and register their event handlers. GUI-referencing functions must be stubbed with no-op replacements or dummy objects (NOT None -- methods must be callable on them).

### REQ-API: SWIG API Compatibility

#### REQ-API-01: Function Count (Revised)
| Category | Count |
|----------|-------|
| Must Implement (full behavior) | ~330 |
| Stub OK (return None/0/no-op) | ~190 |
| Not Needed (client-only) | ~75 |
| **Total Functions** | **~595** |
| Constants | ~345 |
| Singleton Globals | ~29 |

#### REQ-API-02: Handle System
SWIG pointer string handles `_HEXID_p_TypeName` mapping to flecs entity IDs. Type hierarchy checking, null handle detection, generation tracking.

#### REQ-API-03: Singleton Globals
g_kUtopiaModule, g_kEventManager, g_kTimerManager, g_kRealtimeTimerManager, g_kVarManager, g_kSetManager, g_kConfigMapping, g_kLocalizationManager, g_kModelPropertyManager, g_kSystemWrapper.

#### REQ-API-04: New Gameplay Classes (Delta from Lobby)
| Class | Methods | Priority |
|-------|---------|----------|
| ShipClass / BaseObjectClass | ~55 | Critical |
| WeaponHitEvent / ObjectExplodingEvent | ~15 | High (stubs for Phase 1) |
| ObjectGroup / ObjectGroupWithInfo | ~12 | High |
| TGSequence / TGScriptAction | ~20 | Medium |
| 16 Property types (Phaser, Shield, Hull, etc.) | ~18 Create + ~200 Set* | Medium |
| TGPoint3 / TGColorA | ~25 | Medium |
| ProximityManager | ~8 | Low (Mission5 only) |
| TopWindow / MultiplayerWindow (stubs) | ~15 | Medium (return dummy objects) |

### REQ-ECS: Entity Component System

#### REQ-ECS-01: Ship Components
```c
typedef struct { uint32_t obj_id; uint16_t net_type; char name[64]; } ObcShipIdentity;
typedef struct { uint32_t net_player_id; bool is_player_ship; } ObcShipOwnership;
// Tags: ObcShipAlive, ObcShipDying, ObcShipDead
```

#### REQ-ECS-02: Game State Singletons
```c
typedef struct { uint32_t next_obj_id; bool game_over; bool ready_for_new_players; char mission_script[128]; } ObcGameSession;
typedef struct { uint8_t system_species; int16_t time_limit; int16_t frag_limit; uint8_t player_limit; float time_left; } ObcMatchConfig;
```

#### REQ-ECS-03: Custom Pipeline
`NetworkReceive -> Checksum -> Lobby -> GameplayRelay -> EventDispatch -> NetworkSend -> Cleanup`

### REQ-CFG: Configuration

#### REQ-CFG-01: Command-Line Arguments
```
--port=22101           --max-players=16       --game-name="OpenBC"
--map=<episode>        --script-path=scripts/ --config=stbc.cfg
--skip-checksums       --mission=Mission1     --time-limit=10
--frag-limit=20        --password=<string>
```

### REQ-BLD: Build System

CMake 3.20+, C11, flecs v4.1.4 vendored, Python 3.8+, `OPENBC_SERVER_ONLY=ON`. Cross-platform (Linux primary, Windows, macOS). Docker (~150-170 MB). GitHub Actions CI.

### REQ-MOD: Mod Compatibility

#### REQ-MOD-01: Vanilla Ships
All 50+ vanilla ship/hardpoint scripts must execute successfully.

#### REQ-MOD-02: Custom Ships
Custom ship mods using the same Property API as vanilla ships SHOULD work without modification.

#### REQ-MOD-03: Mission Scripts
Missions 1-3 MUST load, register handlers, and manage game lifecycle. Mission5 (coop) deferred.

#### REQ-MOD-04: Mode Detection
`IsHost()` = True, `IsClient()` = False, `IsMultiplayer()` = True for dedicated server.

#### REQ-MOD-05: Modifier Table
`Multiplayer/Modifier.py` damage modifier table MUST load. OpenBC SHOULD add bounds checking with fallback to modifier 1.0 for out-of-range ship classes.

---

## 4. Non-Functional Requirements

### NFR-01: Tick Rate
30 Hz (33ms per tick), matching original game.

### NFR-02: Performance
16 simultaneous connections with active gameplay relay. Target: < 10% CPU on a single modern core.

### NFR-03: Memory
Server footprint < 100 MB RAM (excluding Python).

### NFR-04: Bandwidth
~5-10 KB/s per client (6 players), ~12-24 KB/s per client (16 players). Position updates unreliable, game logic reliable.

### NFR-05: Endianness
All protocol values little-endian regardless of host platform.

### NFR-06: Clean Clone Build
`cmake -B build -DOPENBC_SERVER_ONLY=ON && cmake --build build` on all platforms with zero manual setup.

---

## 5. Design Decisions

### DD-01: Raw UDP, Not ENet
ENet wire format incompatible with vanilla BC clients.

### DD-02: Rewrite App.py
Original has 1,004 `apply()` + 2,521 `new.instancemethod()`. Rewrite rather than transform.

### DD-03: flecs for Game State
Cache-friendly ECS with query system. Maps cleanly to SWIG handle system.

### DD-04: Relay-Only, No Simulation
Phase 1 trusts clients. The server relays raw message bytes without physics, damage, or AI simulation. Each client runs the full game engine locally and they agree on outcomes because they all run the same deterministic simulation.

### DD-05: Scoring Deferred to Phase 2
The original host generates ET_WEAPON_HIT and ET_OBJECT_EXPLODING from its C++ damage pipeline. A relay server has no damage pipeline, so these events never fire. Phase 2 will parse specific opcodes from the relay stream to synthesize scoring events.

### DD-06: Dummy Objects for UI Stubs
Headless mode stubs MUST return dummy callable objects (not None) so that method calls like `pButton.SetEnabled(0)` don't crash with AttributeError. `RestartGame()` and other functions access UI widget methods.

### DD-07: Generic Property System
The ~200 `Set*` methods across 16 property types can be implemented as a generic property base class that accepts any Set*/Get* call as a no-op. Scripts write properties during ship creation but the relay server does not use them.

---

## 6. Dependencies

### Game Data (User-Supplied)
- `scripts/` directory including `Multiplayer/`, `ships/`, `mainmenu/`
- `stbc.cfg`

### RE Data (From STBC-Dedicated-Server)
- 4x256-byte hash lookup tables from stbc.exe (at 0x0095c888-0x0095cb87)
- Reference string from PTR_DAT_008d9af4
- ET_* event type numeric values (confirmed via decompilation, see [phase1-re-gaps.md](phase1-re-gaps.md) Section 1.8)
- Verified game opcode table (34 opcodes with gaps, NOT sequential 0x00-0x2B)
- AlbyRules stream cipher key ("AlbyRules!" -- 10-byte XOR)
- Complete wire format specification (see [phase1-verified-protocol.md](phase1-verified-protocol.md))
- MAX_MESSAGE_TYPES = 0x2B (43), not 0x2C

---

## 7. Test Plan

| Test | Method | Pass Criteria |
|------|--------|---------------|
| Server starts | Run binary | Binds port, no crash |
| LAN discovery | BC client scan | Server visible with correct info |
| Client connect | BC client join | Connection + slot assigned |
| Checksum exchange | BC client join | All 4 rounds pass |
| Settings received | BC client join | Ship selection screen reached |
| **Ship selection** | Select ship in BC | Ship created, broadcast to other clients |
| **Gameplay relay** | 2+ clients in match | Movement, weapons, combat all functional |
| **Chat** | Type message in game | Message appears on all clients |
| **Game end** | Time/frag limit hit | END_GAME_MESSAGE received by all |
| **Restart** | Host restarts | All clients return to ship select |
| **Late join** | Client joins mid-game | Receives MISSION_INIT, can play |
| Multi-client | 2+ BC clients | Separate slots, independent play |
| Disconnect | Kill BC client | Server detects, frees slot, game continues |
| Reconnect | Client rejoins | New slot, fresh checksums |
| Max players | 17th client | Rejected correctly |
| Keepalive | Client idle 60s | Still connected |
| Docker | Container run | Accessible from host network |
| Cross-platform | Linux/Win/Mac CI | All builds succeed |

---

## 8. Risk Register

| Risk | Probability | Impact | Mitigation | Status |
|------|-------------|--------|------------|--------|
| Wire format mismatch | ~~HIGH~~ **LOW** | HIGH | **SOLVED**: Complete wire format verified from 30K+ packet traces. See [phase1-verified-protocol.md](phase1-verified-protocol.md) | Resolved |
| Hash algorithm mismatch | ~~MEDIUM~~ **LOW** | HIGH | **SOLVED**: 4x256-byte tables extracted, algorithm fully traced (FUN_007202e0) | Resolved |
| ACK priority queue stall | ~~HIGH~~ **LOW** | HIGH | **SOLVED**: Three-tier queue system fully reverse-engineered with timeouts and retry logic | Resolved |
| Python 1.5.2 edge cases | MEDIUM | MEDIUM | Test against full vanilla script corpus | Open |
| ET_* values unknown | ~~HIGH~~ **LOW** | HIGH | **SOLVED**: Key values confirmed via decompilation (see re-gaps.md Section 1.8) | Resolved |
| Game opcode relay ordering | ~~MEDIUM~~ **LOW** | MEDIUM | **SOLVED**: Complete opcode table with jump table addresses and frequency counts | Resolved |
| UI stub coverage gaps | HIGH | MEDIUM | Add stubs reactively as crashes found | Open |
| list.sort(cmp_func) breakage | HIGH | MEDIUM | Compat shim with functools.cmp_to_key | Open |
| Ship creation protocol unknown | ~~MEDIUM~~ **LOW** | HIGH | **SOLVED**: ObjectCreateTeam (0x03) with vtable+0x10C serialization. Working in STBC-Dedi | Resolved |
| Late join state sync incomplete | MEDIUM | MEDIUM | InitNetwork sends config; test with vanilla | Open |
| Scoring not authoritative (Phase 1) | LOW | LOW | Accepted limitation; each client tracks locally | Accepted |
